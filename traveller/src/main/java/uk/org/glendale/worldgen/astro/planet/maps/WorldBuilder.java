/*
 * Copyright (C) 2011 Samuel Penn, sam@glendale.org.uk
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; version 2.
 * See the file COPYING.
 */
package uk.org.glendale.worldgen.astro.planet.maps;

import java.awt.GraphicsEnvironment;
import java.awt.image.BufferedImage;
import java.io.File;
import java.util.HashMap;

import javax.persistence.EntityManager;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.springframework.stereotype.Controller;

import uk.org.glendale.graphics.SimpleImage;
import uk.org.glendale.rpg.traveller.systems.codes.AtmospherePressure;
import uk.org.glendale.rpg.traveller.systems.codes.AtmosphereType;
import uk.org.glendale.rpg.traveller.systems.codes.LifeType;
import uk.org.glendale.rpg.utils.Die;
import uk.org.glendale.worldgen.astro.planet.Builder;
import uk.org.glendale.worldgen.astro.planet.MapImage;
import uk.org.glendale.worldgen.astro.planet.Planet;
import uk.org.glendale.worldgen.astro.planet.PlanetType;
import uk.org.glendale.worldgen.astro.planet.builders.MapDrawer;
import uk.org.glendale.worldgen.astro.planet.builders.PlanetDescription;
import uk.org.glendale.worldgen.astro.planet.builders.barren.Hermian;
import uk.org.glendale.worldgen.astro.planet.maps.Tile;
import uk.org.glendale.worldgen.astro.star.Star;
import uk.org.glendale.worldgen.civ.commodity.Commodity;
import uk.org.glendale.worldgen.civ.commodity.CommodityFactory;
import uk.org.glendale.worldgen.server.AppManager;

/**
 * Abstract planet building class. Provides the basic framework for constructing
 * a random planet. Extended by more specific abstract examples which describe
 * broad types of worlds, and finally by concrete classes for each PCS type.
 * 
 * The PlanetGenerator creates the initial planet, determines which
 * PlanetBuilder to use and passes the new planet to the builder, which fills in
 * all the details.
 * 
 * @see BarrenWorld
 * @see GaianWorld
 * @see IceWorld
 * @see JovianWorld
 * 
 * @author Samuel Penn.
 */
public abstract class WorldBuilder implements Builder {
	protected Planet planet;
	protected Star star;

	protected CommodityFactory commodityFactory;
	
	protected HashMap<String,Object>	properties = new HashMap<String,Object>();

	/**
	 * Create a new PlanetBuilder object. Generates a fractal height map for the
	 * world on the assumption that most worlds will require this.
	 */
	public WorldBuilder() {
	}
	
	public void setCommodityFactory(CommodityFactory factory) {
		this.commodityFactory = factory;
	}

	/**
	 * Gets the type of this planet, according to the PCL. Will always return a
	 * valid value.
	 * 
	 * @return Gets the PCL type.
	 */
	public abstract PlanetType getPlanetType();

	/**
	 * Sets the star that is the primary for this world. This must be set before
	 * the world can be generated since it is used to determine certain world
	 * characteristics.
	 * 
	 * @param star
	 *            Primary star for this world.
	 */
	public void setStar(Star star) {
		this.star = star;
	}

	/**
	 * Gets the star that is being used by this builder.
	 * 
	 * @return Star that is being used.
	 */
	public Star getStar() {
		return star;
	}

	/**
	 * Sets the planet that is to be generated. The planet will be modified
	 * according to the rules for the given type of builder. Astronomical
	 * statistics, such as orbital distance, will not be touched.
	 * 
	 * @param planet
	 *            Planet to be generated by this builder.
	 */
	public void setPlanet(Planet planet) {
		this.planet = planet;

		planet.setType(PlanetType.Undefined);
		planet.setRadius(getPlanetType().getRadius());
		planet.setAtmosphere(AtmosphereType.Vacuum);
		planet.setPressure(AtmospherePressure.None);

		planet.setLifeType(LifeType.None);
	}

	/**
	 * Gets the planet that this builder is building.
	 * 
	 * @return Planet that is in use.
	 */
	public Planet getPlanet() {
		return planet;
	}

	/**
	 * Checks that all the necessary setters have been called. If anything is
	 * missing, then an exception is thrown. Should be called by public methods
	 * which require this information.
	 * 
	 * @throws IllegalStateException
	 *             Thrown if builder has not been set up.
	 */
	protected void validate() {
		if (star == null) {
			throw new IllegalStateException(
					"Star has not yet been set for this builder");
		}
		if (planet == null) {
			throw new IllegalStateException(
					"Planet has not yet been set for this builder");
		}
	}

	/**
	 * Adds a resource to the list of resources that this planet provides.
	 * 
	 * @param commodityName
	 *            Name of the resource.
	 * @param density
	 *            Density of the resource, from 1-100.
	 */
	public void addResource(String commodityName, int density) {
		validate();
		Commodity commodity = commodityFactory.getCommodity(commodityName);
		if (commodity == null) {
			throw new IllegalArgumentException("Cannot find commodity ["
					+ commodityName + "]");
		}
		addResource(commodity, density);
	}

	public void addResource(Commodity commodity, int density) {
		validate();
		planet.addResource(commodity, density);
	}

	/**
	 * Generate standard planetary statistics.
	 */
	public abstract void generate();

	/**
	 * Generate surface map for this planet.
	 */
	public abstract void generateMap();

	/**
	 * Generate resources for this planet.
	 */
	public abstract void generateResources();

	public void generateDescription() {
		validate();
		//PlanetDescription description = new PlanetDescription(this);
		//planet.setDescription(description.getFullDescription());
	}

	protected Icosohedron		model = new Icosohedron();
	protected Tile[][]		map;
	
	protected static final Tile	OOB = new Tile("OOB", "#FFFFFF", false);
	protected static final Tile	BLANK = new Tile("BLANK", "#000000", false);

	/**
	 * Blur the image. Randomly copies pixels to their neighbour, to break
	 * up and hard geometric patterns. Doesn't touch pure white pixels, since
	 * these are assumed to be off-map background pixels.
	 */
	protected void blur(BufferedImage image) {
		for (int y=0; y < image.getHeight(); y++) {
			for (int x=0; x < image.getWidth(); x++) {
				int c = image.getRGB(x, y) & 0xFFFFFF;
				if (c == 0xFFFFFF) {
					continue;
				}
				int r = (c >> 16) & 0xFF;
				int g = (c >> 8) & 0xFF;
				int b = c & 0xFF;
				switch (Die.d8()) {
				case 1:
					if (y > 0) {
						c = image.getRGB(x, y-1);
					}
					break;
				case 2:
					if (y < image.getHeight() - 1) {
						c = image.getRGB(x, y+1);
					}
					break;
				case 3:
					if (x > 0) {
						c = image.getRGB(x-1, y);
					}
					break;
				case 4:
					if (x < image.getWidth() - 1) {
						c = image.getRGB(x+1, y);
					}
					break;
				default:
					break;
				}
				if ((c & 0xFFFFFF) != 0xFFFFFF) {
					image.setRGB(x, y, c);
				}
			}
		}
	}
	
	protected SimpleImage postProcess(SimpleImage image) {
		return image;
	}

	public SimpleImage getImage() {
		SimpleImage image = null;
		try {
			image = postProcess(model.draw(map, properties));
			MapImage surfaceMap = new MapImage();
			surfaceMap.setType(MapImage.Projection.Icosohedron);
			surfaceMap.setData(image.save().toByteArray());
			planet.addImage(surfaceMap);
			
			MapImage stretchedMap = new MapImage();
			stretchedMap.setType(MapImage.Projection.Mercator);
			stretchedMap.setData(model.stretchImage(image));
			planet.addImage(stretchedMap);

			System.out.println("Saving image for " + getPlanetType());
			if (!new File("/tmp/maps").exists()) {
				new File("/tmp/maps").mkdir();
			}
			image.save(new File("/tmp/maps/" + planet.getId() + "_" + 
					planet.getType() + ".jpg"));

			if (AppManager.getDrawGlobe()) {
				MapImage globeMap = new MapImage();
				globeMap.setType(MapImage.Projection.Globe);
				//globeMap.setData(drawer.getWorldGlobe(2).save().toByteArray());
				planet.addImage(globeMap);
			}
			System.out.println("Done");
		} catch (Throwable e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return image;
	}

	/**
	 * Get a list of moon types to add to this world. This list is used to
	 * generate the moons after the planet has been persisted. If the list is
	 * null or empty, the world has no moons.
	 * 
	 * @return List of planet types for moons.
	 */
	public WorldBuilder[] getMoonBuilders() {
		return null;
	}

	/**
	 * Get the distance to the first moon of this planet. This is based on the
	 * size of the planet and the typical size of the moon.
	 * 
	 * @return Distance in kilometres.
	 */
	public int getFirstMoonDistance() {
		if (getMoonBuilders() != null && getMoonBuilders().length > 0) {
			int distance = (planet.getRadius() * getMoonBuilders()[0]
					.getPlanetType().getRadius()) / (200 + Die.d100(2));
			if (getMoonBuilders()[0].getPlanetType().getRadius() > planet
					.getRadius() / 5) {
				// This is closer to being a double planet system, so
				// greatly increase the distance.
				distance *= 10;
			}
			return distance;
		}
		return 0;
	}

	public static void main(String[] args) throws Exception {
		System.out.println(GraphicsEnvironment.isHeadless());
		/*
		PlanetBuilder barren = new Hermian();
		barren.setPlanet(new Planet());
		barren.generate();
		*/
		System.exit(0);

		/*
		 * Tile sea = new Tile("Sea", "#505050", false); Tile crust = new
		 * Tile("Crust", "#909090", false); Tile mountains = new
		 * Tile("Mountains", "#B0B0B0", false); barren.addContinents(sea, crust,
		 * mountains); barren.getImage();
		 */
	}

}
